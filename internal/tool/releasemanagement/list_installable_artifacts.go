package releasemanagement

import (
	"context"
	"fmt"
	"net/http"
	"strconv"

	"github.com/bitrise-io/bitrise-mcp/v2/internal/bitrise"
	"github.com/mark3labs/mcp-go/mcp"
)

var ListInstallableArtifacts = bitrise.Tool{
	APIGroups: []string{"release-management", "read-only"},
	Definition: mcp.NewTool("list_installable_artifacts",
		mcp.WithDescription("List Release Management installable artifacts of a connected app available for the authenticated account."),
		mcp.WithString("connected_app_id",
			mcp.Description("Identifier of the Release Management connected app for the installable artifacts. This field is mandatory."),
			mcp.Required(),
		),
		mcp.WithString("after_date",
			mcp.Description("A date in ISO 8601 string format specifying the start of the interval when the installable artifact to be returned was created or uploaded. This value will be defaulted to 1 month ago if distribution_ready filter is not set or set to false."),
		),
		mcp.WithString("artifact_type",
			mcp.Description("Filters for a specific artifact type or file extension for the list of installable artifacts. Available values are: 'aab' and 'apk' for android artifacts and 'ipa' for ios artifacts."),
			mcp.Enum("aab", "apk", "ipa"),
		),
		mcp.WithString("before_date",
			mcp.Description("A date in ISO 8601 string format specifying the end of the interval when the installable artifact to be returned was created or uploaded. This value will be defaulted to the current time if distribution_ready filter is not set or set to false."),
		),
		mcp.WithString("branch",
			mcp.Description("Filters for the Bitrise CI branch of the installable artifact on which it has been generated on."),
		),
		mcp.WithBoolean("distribution_ready",
			mcp.Description("Filters for distribution ready installable artifacts. This means .apk and .ipa (with distribution type ad-hoc, development, or enterprise) installable artifacts."),
		),
		mcp.WithNumber("items_per_page",
			mcp.Description("Specifies the maximum number of installable artifacts to be returned per page. Default value is 10."),
			mcp.DefaultNumber(10),
		),
		mcp.WithNumber("page",
			mcp.Description("Specifies which page should be returned from the whole result set in a paginated scenario. Default value is 1."),
			mcp.DefaultNumber(1),
		),
		mcp.WithString("platform",
			mcp.Description("Filters for a specific mobile platform for the list of installable artifacts. Available values are: 'ios' and 'android'."),
			mcp.Enum("ios", "android"),
		),
		mcp.WithString("search",
			mcp.Description("Search by version, filename or build number (Bitrise CI). The filter is case-sensitive."),
		),
		mcp.WithString("source",
			mcp.Description("Filters for the source of installable artifacts to be returned. Available values are 'api' and 'ci'."),
			mcp.Enum("api", "ci"),
		),
		mcp.WithBoolean("store_signed",
			mcp.Description("Filters for store ready installable artifacts. This means signed .aab and .ipa (with distribution type app-store) installable artifacts."),
		),
		mcp.WithString("version",
			mcp.Description("Filters for the version this installable artifact was created for. This field is required if the distribution_ready filter is set to true."),
		),
		mcp.WithString("workflow",
			mcp.Description("Filters for the Bitrise CI workflow of the installable artifact it has been generated by."),
		),
		mcp.WithReadOnlyHintAnnotation(true),
		mcp.WithDestructiveHintAnnotation(false),
		mcp.WithOpenWorldHintAnnotation(true),
		mcp.WithIdempotentHintAnnotation(true),
	),
	Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		connectedAppID, err := request.RequireString("connected_app_id")
		if err != nil {
			return mcp.NewToolResultError(err.Error()), nil
		}

		params := map[string]any{}
		if v := request.GetString("after_date", ""); v != "" {
			params["after_date"] = v
		}
		if v := request.GetString("artifact_type", ""); v != "" {
			params["artifact_type"] = v
		}
		if v := request.GetString("before_date", ""); v != "" {
			params["before_date"] = v
		}
		if v := request.GetString("branch", ""); v != "" {
			params["branch"] = v
		}
		if _, ok := request.GetArguments()["distribution_ready"]; ok {
			v := request.GetBool("distribution_ready", false)
			params["distribution_ready"] = strconv.FormatBool(v)
		}
		if v := request.GetInt("items_per_page", 10); v != 10 {
			params["items_per_page"] = strconv.Itoa(v)
		}
		if v := request.GetInt("page", 1); v != 1 {
			params["page"] = strconv.Itoa(v)
		}
		if v := request.GetString("platform", ""); v != "" {
			params["platform"] = v
		}
		if v := request.GetString("search", ""); v != "" {
			params["search"] = v
		}
		if v := request.GetString("source", ""); v != "" {
			params["source"] = v
		}
		if _, ok := request.GetArguments()["store_signed"]; ok {
			v := request.GetBool("store_signed", false)
			params["store_signed"] = strconv.FormatBool(v)
		}
		if v := request.GetString("version", ""); v != "" {
			params["version"] = v
		}
		if v := request.GetString("workflow", ""); v != "" {
			params["workflow"] = v
		}

		res, err := bitrise.CallAPI(ctx, bitrise.CallAPIParams{
			Method:  http.MethodGet,
			BaseURL: bitrise.APIRMBaseURL,
			Path:    fmt.Sprintf("/connected-apps/%s/installable-artifacts", connectedAppID),
			Params:  params,
		})
		if err != nil {
			return mcp.NewToolResultErrorFromErr("call api", err), nil
		}
		return mcp.NewToolResultText(res), nil
	},
}
