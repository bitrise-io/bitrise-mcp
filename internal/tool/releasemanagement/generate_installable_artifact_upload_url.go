package releasemanagement

import (
	"context"
	"fmt"
	"net/http"

	"github.com/bitrise-io/bitrise-mcp/v2/internal/bitrise"
	"github.com/mark3labs/mcp-go/mcp"
)

var GenerateInstallableArtifactUploadURL = bitrise.Tool{
	APIGroups: []string{"release-management"},
	Definition: mcp.NewTool("generate_installable_artifact_upload_url",
		mcp.WithDescription("Generates a signed upload url valid for 1 hour for an installable artifact to be uploaded to Bitrise Release Management. The response will contain an url that can be used to upload an artifact to Bitrise Release Management using a simple curl request with the file data that should be uploaded. The necessary headers and http method will also be in the response. This artifact will need to be processed after upload to be usable. The status of processing can be checked by making another request to a different url giving back the processed status of an installable artifact."),
		mcp.WithString("connected_app_id",
			mcp.Description("Identifier of the Release Management connected app for the installable artifact. This field is mandatory."),
			mcp.Required(),
		),
		mcp.WithString("installable_artifact_id",
			mcp.Description("An uuidv4 identifier generated on the client side for the installable artifact. This field is mandatory."),
			mcp.Required(),
		),
		mcp.WithString("file_name",
			mcp.Description("The name of the installable artifact file (with extension) to be uploaded to Bitrise. This field is mandatory."),
			mcp.Required(),
		),
		mcp.WithString("file_size_bytes",
			mcp.Description("The byte size of the installable artifact file to be uploaded."),
			mcp.Required(),
		),
		mcp.WithString("branch",
			mcp.Description("Optionally you can add the name of the CI branch the installable artifact has been generated on."),
		),
		mcp.WithBoolean("with_public_page",
			mcp.Description("Optionally, you can enable public install page for your artifact. This can only be enabled by Bitrise Project Admins, Bitrise Project Owners and Bitrise Workspace Admins. Changing this value without proper permissions will result in an error. The default value is false."),
			mcp.DefaultBool(false),
		),
		mcp.WithString("workflow",
			mcp.Description("Optionally you can add the name of the CI workflow this installable artifact has been generated by."),
		),
	),
	Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		connectedAppID, err := request.RequireString("connected_app_id")
		if err != nil {
			return mcp.NewToolResultError(err.Error()), nil
		}
		installableArtifactID, err := request.RequireString("installable_artifact_id")
		if err != nil {
			return mcp.NewToolResultError(err.Error()), nil
		}
		fileName, err := request.RequireString("file_name")
		if err != nil {
			return mcp.NewToolResultError(err.Error()), nil
		}
		fileSizeBytes, err := request.RequireString("file_size_bytes")
		if err != nil {
			return mcp.NewToolResultError(err.Error()), nil
		}

		params := map[string]string{
			"file_name":       fileName,
			"file_size_bytes": fileSizeBytes,
		}
		if v := request.GetString("branch", ""); v != "" {
			params["branch"] = v
		}
		if v := request.GetBool("with_public_page", false); v {
			params["with_public_page"] = "true"
		}
		if v := request.GetString("workflow", ""); v != "" {
			params["workflow"] = v
		}

		res, err := bitrise.CallAPI(ctx, bitrise.CallAPIParams{
			Method:  http.MethodGet,
			BaseURL: bitrise.APIRMBaseURL,
			Path:    fmt.Sprintf("/connected-apps/%s/installable-artifacts/%s/upload-url", connectedAppID, installableArtifactID),
			Params:  params,
		})
		if err != nil {
			return mcp.NewToolResultErrorFromErr("call api", err), nil
		}
		return mcp.NewToolResultText(res), nil
	},
}
